package azura.common.sound{	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.SampleDataEvent;	import flash.events.StatusEvent;	import flash.events.TimerEvent;	import flash.media.Microphone;	import flash.media.SoundCodec;	import flash.utils.ByteArray;	import flash.utils.Timer;	import flash.utils.getTimer;		import fr.kikko.lab.ShineMP3Encoder;		import mx.core.FlexGlobals;
		public final class SpeexRecorderOld 	{			private static var bitrate:int=32;				private static var _microphone:Microphone;		private static var _buffer:ByteArray;		private static var timer:Timer;		private static var stopRequested:Boolean;				public static var status:String;				private static var dispatcher:EventDispatcher=new EventDispatcher();				{			_microphone=Microphone.getMicrophone();			if(_microphone!=null){				_microphone.codec=SoundCodec.SPEEX;							_microphone.setSilenceLevel(0);				_microphone.gain=20;				_microphone.rate = 16;				_microphone.encodeQuality=10;			}		}				public static function get hasMic():Boolean{			return _microphone!=null;		}				public static function addEventListener(type:String,listener:Function):void{			dispatcher.addEventListener(type,listener);		}				public static function removeEventListener(type:String,listener:Function):void{			dispatcher.removeEventListener(type,listener);		}				public static function get isRecording():Boolean{			return timer!=null;		}				public static function record(maxTime:int=10):void		{						if(isRecording||isCompressing)				return;						_buffer=new ByteArray();			_microphone.addEventListener(SampleDataEvent.SAMPLE_DATA, onSampleData);						timer=new Timer(1000,maxTime);			timer.addEventListener(TimerEvent.TIMER,onTick);			timer.addEventListener(TimerEvent.TIMER_COMPLETE,onComplete);			timer.start();						trace("Recorder: timer tick "+(timer.currentCount+1));			status=(timer.currentCount+1)+"/"+timer.repeatCount;			dispatcher.dispatchEvent(new TimerEvent(TimerEvent.TIMER));		}				public static function stop():void{			if(isRecording&&!isCompressing)				stopRequested=true;		}				private static function onTick(event:TimerEvent):void{			if(timer.currentCount==timer.repeatCount)				return;						status=(timer.currentCount+1)+"/"+timer.repeatCount;						if(stopRequested){				stopRecording();				compress();			}else{				dispatcher.dispatchEvent(event.clone());			}		}				private static function onComplete(event:TimerEvent):void		{						trace("Recorder: timer stop");			stopRecording();			compress();		}				private static function onSampleData(event:SampleDataEvent):void		{			while(event.data.bytesAvailable >= 8){				_buffer.writeFloat(event.data.readFloat());				_buffer.writeFloat(event.data.readFloat());			}		}				private static var mp3Encoder:ShineMP3Encoder;		private static function get isCompressing():Boolean{			return mp3Encoder!=null;		}		private static function compress():void{			if(isCompressing)				return;						var wavData:ByteArray = WaveEncoder.encode(_buffer);			_buffer=null;						mp3Encoder = new ShineMP3Encoder(wavData,bitrate);			mp3Encoder.addEventListener(Event.COMPLETE, mp3EncodeComplete);			mp3Encoder.start();							dispatcher.dispatchEvent(new TimerEvent(TimerEvent.TIMER_COMPLETE));			function mp3EncodeComplete(e: Event) : void 			{				mp3Encoder.removeEventListener(Event.COMPLETE, mp3EncodeComplete);				var output:ByteArray=new ByteArray();				output.writeBytes(mp3Encoder.mp3Data);				output.position=0;				mp3Encoder=null;				if(output.length>0)					dispatcher.dispatchEvent( new SpeexEvent(output) );				else{					dispatcher.dispatchEvent( new Event(Event.CANCEL) );					//					Alert.show("未能采集到声音信号","设备问题");				}				//				trace("SpeexRecorder encode: "+mp3Encoder.mp3Data.length/1000+"kb / "+mp3Encoder.wavData.length/1000 +"kb");			}			}				private static function stopRecording():void{			_microphone.removeEventListener(SampleDataEvent.SAMPLE_DATA, onSampleData);						stopRequested=false;			if(timer!=null){				timer.stop();				timer.removeEventListener(TimerEvent.TIMER,onTick);				timer.removeEventListener(TimerEvent.TIMER_COMPLETE,onComplete);			}			timer=null;		}				public static function discard():void{			if(isCompressing)				return;						stopRecording();			_buffer=null;			dispatcher.dispatchEvent( new Event(Event.CANCEL) );		}	}}