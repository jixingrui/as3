package azura.common.sound{	import azura.common.panels.AlertPanel;		import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.SampleDataEvent;	import flash.events.StatusEvent;	import flash.events.TimerEvent;	import flash.media.Microphone;	import flash.media.SoundCodec;	import flash.utils.ByteArray;	import flash.utils.Timer;	import flash.utils.getTimer;		import fr.kikko.lab.ShineMP3Encoder;		import mx.core.FlexGlobals;		import org.osflash.signals.Signal;
		public final class SpeexRecorder	{			private static var bitrate:int=32;				private static var _microphone:Microphone;		private static var _buffer:ByteArray;		private static var timer:Timer;		private static var stopRequested:Boolean;				private static var _onSend:Signal=new Signal(ByteArray);						{			_microphone=Microphone.getMicrophone();			if(_microphone!=null){				_microphone.codec=SoundCodec.SPEEX;							_microphone.setSilenceLevel(0);				_microphone.gain=20;				_microphone.rate = 16;				_microphone.encodeQuality=10;			}		}				public static function get onSend():Signal
		{
			return _onSend;
		}		public static function get hasMic():Boolean{			return _microphone!=null;		}				public static function get isRecording():Boolean{			return timer!=null;		}				public static function record(maxTime:int=10):void		{			if(isRecording||isCompressing||_microphone==null)				return;						_buffer=new ByteArray();			_microphone.addEventListener(SampleDataEvent.SAMPLE_DATA, onSampleData);						timer=new Timer(1000,maxTime);			timer.addEventListener(TimerEvent.TIMER,onTick);			timer.addEventListener(TimerEvent.TIMER_COMPLETE,onComplete);			timer.start();		}				public static function stop():void{			if(isRecording&&!isCompressing)				stopRequested=true;						if(_microphone==null)				onSend.dispatch(null);		}				private static function onTick(event:TimerEvent):void{			if(timer.currentCount==timer.repeatCount)				return;									if(stopRequested){				stopRecording();				compress();			}		}				private static function onComplete(event:TimerEvent):void		{						stopRecording();			compress();		}				private static function onSampleData(event:SampleDataEvent):void		{			while(event.data.bytesAvailable >= 8){				_buffer.writeFloat(event.data.readFloat());				_buffer.writeFloat(event.data.readFloat());			}		}				private static var mp3Encoder:ShineMP3Encoder;		private static function get isCompressing():Boolean{			return mp3Encoder!=null;		}		private static function compress():void{			if(isCompressing)				return;						var wavData:ByteArray = WaveEncoder.encode(_buffer);			_buffer=null;						mp3Encoder = new ShineMP3Encoder(wavData,bitrate);			mp3Encoder.addEventListener(Event.COMPLETE, mp3EncodeComplete);			mp3Encoder.start();							function mp3EncodeComplete(e: Event) : void 			{				mp3Encoder.removeEventListener(Event.COMPLETE, mp3EncodeComplete);				var output:ByteArray=new ByteArray();				output.writeBytes(mp3Encoder.mp3Data);				output.position=0;				mp3Encoder=null;				if(output.length>0)					onSend.dispatch(output);				else{					AlertPanel.show("未能采集到声音信号","设备问题");				}			}			}				private static function stopRecording():void{			_microphone.removeEventListener(SampleDataEvent.SAMPLE_DATA, onSampleData);						stopRequested=false;			if(timer!=null){				timer.stop();				timer.removeEventListener(TimerEvent.TIMER,onTick);				timer.removeEventListener(TimerEvent.TIMER_COMPLETE,onComplete);			}			timer=null;		}				public static function discard():void{			if(isCompressing)				return;						stopRecording();			_buffer=null;		}	}}